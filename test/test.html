<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // fetch('https://jsonplaceholder.typicode.commm/users')
    // .then((response)=> response.text())
    // .then((result)=>{console.log(result)})
    // .catch((error)=>{console.log(error)})
    // .finally(()=>{console.log('exit')})
    
    /*
      이 상태로는 catch메소드가 리턴했던 프로미스 객체가
      fulfilled 상태가 되고 undefined를 작업성공결과로 갖게 된다.
    */

    // catch메소드가 리턴한 프로미스 객체를 rejected 상태로 만들기 위해서 코드를 바꿨다.
    fetch('https://jsonplaceholder.typicode.commm/users')
    .then((response)=> response.text())
    .then((result)=>{console.log(result)})
    .catch((error)=>{
      console.log(error);
      throw new Error('from catch method')
    })
    .finally(()=>{console.log('exit')})
    /*
      이렇게 되면 catch메소드가 리턴했던 프로미스객체가 rejected 상태가 된다.
      - 물론 catch메소드 안에서 발생한 에러는 결국 처리되지 못했지만 
      finally안의 콜백은 잘 실행된다.
      - 에러를 처리하는 catch메소드안에서 에러가 발생하더라도 finally 메소드 안의 콜백은 실행된다는 뜻이다.
    */
  </script>
</body>
</html>