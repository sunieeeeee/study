<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2_async, await 구문의 실행원리</title>
</head>
<body>
  <script>
    /* 
      ● async/await 구문의 실행 원리
      - await은 async 함수 안에서만 사용할 수 있다.
      - await을 만나면 일단 그 뒤의 코드를 실행하고
    
    */

    // async함수 주변에 여러 코드 추가하기
    async function fetchAndPrint() {
      console.log(2);
      const response = await fetch('https://jsonplaceholder.typicode.com/users');
      console.log(7);
      const result = await response.text();
      console.log(result);
    }

    console.log(1);
    fetchAndPrint();
    console.log(3);
    console.log(4);
    console.log(5);
    console.log(6);

    /* 
      - console.log() 에 아규먼트로 있는 숫자의 순서대로 console.log()가 실행된다.
      
      [순서]
      1. 
        async function fetchAndPrint() {
          console.log(2);
          const response = await fetch('https://jsonplaceholder.typicode.com/users');
          console.log(7);
          const result = await response.text();
          console.log(result);
        }
        에서 함수를 선언한다.

      2. 그 다음 console.log(1)의 1이 출력된다.
      3. 그리고 fetchAndPrint가 실행되고
         fetchAndPrint 함수 안에서 2가 출력된다.
      4. 그리고 
         const response = await fetch('https://jsonplaceholder.typicode.com/users'); 
         에서 awiat을 만난다.

         * await을 만나면 일단 그 뒤의 코드를 실행하고
         코드의  실행 흐름은 fetchAndPrint 함수를 호출한 곳으로 가게 된다.
         (fetchAndPrint 함수 바깥으로 실행흐름이 바뀜)

         그래서 console.log(3)의 3이 출력된다.
      5. 그리고 그 다음에 남은 코드들인
         console.log(4);
         console.log(5);
         console.log(6);
         가 실행된다.

         이렇게 바깥 코드가 다 실행된 후에는 
         아까 await문 뒤에 있던 프로미스 객체가 fulfilled상태가 될 때까지 기다린다.

         이때 이미 fulfilled 상태가 되었을 수도 있고
         fulfilled상태가 될때까지 더 기다려야 할 수도 있다.

         어쨌든 fulfilled상태가 되면 
         await은 프로미스 객체의 작업성공결과인 리스폰스 객체를 추출해서 리턴한다.

      6. 그리고 그 다음코드가 실행되어서 7이 출력된다.

      7. 그 다음 또 await을 만난다.
      const result = await response.text();
      이때도 똑같이 일단 await 뒤의 코드가 실행되고
      다시 코드의 실행흐름은 fetchAndPrint 바깥으로 나가게 된다.

      하지만 바깥에는 더이상 실행할 코드가 없다.
      
      그래서 이제는 그냥 이 text메소드가 리턴하는 프로미스 객체가 fulfilled 상태가 될 때까지 기다린다. 

      프로미스 객체가 fulfilled 상태가 되면 
      그 작업성공결과인 실제 리스폰스의 내용이 result에 할당되고
      그 내용이 출력되면서 끝이난다.
    */

    /* 
      function fetchAndPrint() {
        console.log(2);
        fetch('https://jsonplaceholder.typicode.com/users')
          .then((response) => {
            console.log(7);
            return response.text();
          })
          .then((result) => { console.log(result); });
      }

      console.log(1);
      fetchAndPrint();
      console.log(3);
      console.log(4);
      console.log(5);
      console.log(6);

      과 같다.
    */


    /* 
      [정리]
      async 함수 안의 코드가 실행되다가 await을 만나면, 
      일단 await 뒤의 코드가 실행되고,
      코드의 실행 흐름이 async 함수 바깥으로 나가서 나머지 코드를 다 실행한다.
      
      물론 함수 바깥에 더 이상 실행할 코드가 없을 수도 있다.
      어느 경우든 그 이후로는, await 뒤에 있던 Promise 객체가 fulfilled 상태가 되기를 기다린다. 
      그리고 기다리던 Promise 객체가 fulfilled 상태가 되면 await이 Promise 객체의 작업성공겨과를 리턴하는 것이다.
    */
  </script>
</body>
</html>